// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/maps/playablelocations/v3/resources.proto

package playablelocations

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	_ "google.golang.org/genproto/googleapis/type/latlng"
	_ "google.golang.org/genproto/protobuf/field_mask"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The reason why the playable location is considered bad.
type PlayerReport_BadLocationReason int32

const (
	// Unspecified reason. Do not use.
	PlayerReport_BAD_LOCATION_REASON_UNSPECIFIED PlayerReport_BadLocationReason = 0
	// The reason isn't one of the reasons in this enumeration.
	PlayerReport_OTHER PlayerReport_BadLocationReason = 1
	// The playable location isn't accessible to pedestrians. For example, if
	// it's in the middle of a highway.
	PlayerReport_NOT_PEDESTRIAN_ACCESSIBLE PlayerReport_BadLocationReason = 2
	// The playable location isn't open to the public. For example, a private
	// office building.
	PlayerReport_NOT_OPEN_TO_PUBLIC PlayerReport_BadLocationReason = 4
	// The playable location is permanently closed. For example, when a business
	// has been shut down.
	PlayerReport_PERMANENTLY_CLOSED PlayerReport_BadLocationReason = 5
	// The playable location is temporarily inaccessible. For example, when a
	// business has closed for renovations.
	PlayerReport_TEMPORARILY_INACCESSIBLE PlayerReport_BadLocationReason = 6
)

var PlayerReport_BadLocationReason_name = map[int32]string{
	0: "BAD_LOCATION_REASON_UNSPECIFIED",
	1: "OTHER",
	2: "NOT_PEDESTRIAN_ACCESSIBLE",
	4: "NOT_OPEN_TO_PUBLIC",
	5: "PERMANENTLY_CLOSED",
	6: "TEMPORARILY_INACCESSIBLE",
}

var PlayerReport_BadLocationReason_value = map[string]int32{
	"BAD_LOCATION_REASON_UNSPECIFIED": 0,
	"OTHER":                           1,
	"NOT_PEDESTRIAN_ACCESSIBLE":       2,
	"NOT_OPEN_TO_PUBLIC":              4,
	"PERMANENTLY_CLOSED":              5,
	"TEMPORARILY_INACCESSIBLE":        6,
}

func (x PlayerReport_BadLocationReason) String() string {
	return proto.EnumName(PlayerReport_BadLocationReason_name, int32(x))
}

func (PlayerReport_BadLocationReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1fee483de10da73, []int{0, 0}
}

// The type of impression event.
type Impression_ImpressionType int32

const (
	// Unspecified type. Do not use.
	Impression_IMPRESSION_TYPE_UNSPECIFIED Impression_ImpressionType = 0
	// The playable location was presented to a player.
	Impression_PRESENTED Impression_ImpressionType = 1
	// A player interacted with the playable location.
	Impression_INTERACTED Impression_ImpressionType = 2
)

var Impression_ImpressionType_name = map[int32]string{
	0: "IMPRESSION_TYPE_UNSPECIFIED",
	1: "PRESENTED",
	2: "INTERACTED",
}

var Impression_ImpressionType_value = map[string]int32{
	"IMPRESSION_TYPE_UNSPECIFIED": 0,
	"PRESENTED":                   1,
	"INTERACTED":                  2,
}

func (x Impression_ImpressionType) String() string {
	return proto.EnumName(Impression_ImpressionType_name, int32(x))
}

func (Impression_ImpressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1fee483de10da73, []int{1, 0}
}

// A report submitted by a player about a playable location that is considered
// inappropriate for use in the game.
type PlayerReport struct {
	// Required. The name of the playable location.
	LocationName string `protobuf:"bytes,1,opt,name=location_name,json=locationName,proto3" json:"location_name,omitempty"`
	// Required. One or more reasons why this playable location is considered bad.
	Reasons []PlayerReport_BadLocationReason `protobuf:"varint,2,rep,packed,name=reasons,proto3,enum=google.maps.playablelocations.v3.PlayerReport_BadLocationReason" json:"reasons,omitempty"`
	// Required. A free-form description detailing why the playable location is
	// considered bad.
	ReasonDetails string `protobuf:"bytes,3,opt,name=reason_details,json=reasonDetails,proto3" json:"reason_details,omitempty"`
	// Language code (in BCP-47 format) indicating the language of the freeform
	// description provided in `reason_details`. Examples are "en", "en-US" or
	// "ja-Latn". For more information, see
	// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
	LanguageCode         string   `protobuf:"bytes,4,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerReport) Reset()         { *m = PlayerReport{} }
func (m *PlayerReport) String() string { return proto.CompactTextString(m) }
func (*PlayerReport) ProtoMessage()    {}
func (*PlayerReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fee483de10da73, []int{0}
}

func (m *PlayerReport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayerReport.Unmarshal(m, b)
}
func (m *PlayerReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayerReport.Marshal(b, m, deterministic)
}
func (m *PlayerReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerReport.Merge(m, src)
}
func (m *PlayerReport) XXX_Size() int {
	return xxx_messageInfo_PlayerReport.Size(m)
}
func (m *PlayerReport) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerReport.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerReport proto.InternalMessageInfo

func (m *PlayerReport) GetLocationName() string {
	if m != nil {
		return m.LocationName
	}
	return ""
}

func (m *PlayerReport) GetReasons() []PlayerReport_BadLocationReason {
	if m != nil {
		return m.Reasons
	}
	return nil
}

func (m *PlayerReport) GetReasonDetails() string {
	if m != nil {
		return m.ReasonDetails
	}
	return ""
}

func (m *PlayerReport) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// Encapsulates impression event details.
type Impression struct {
	// Required. The name of the playable location.
	LocationName string `protobuf:"bytes,1,opt,name=location_name,json=locationName,proto3" json:"location_name,omitempty"`
	// Required. The type of impression event.
	ImpressionType Impression_ImpressionType `protobuf:"varint,2,opt,name=impression_type,json=impressionType,proto3,enum=google.maps.playablelocations.v3.Impression_ImpressionType" json:"impression_type,omitempty"`
	// An arbitrary, developer-defined type identifier for each type of game
	// object used in your game.
	//
	// Since players interact with differ types of game objects in different ways,
	// this field allows you to segregate impression data by type for analysis.
	//
	// You should assign a unique `game_object_type` ID to represent a distinct
	// type of game object in your game.
	//
	// For example, 1=monster location, 2=powerup location.
	GameObjectType       int32    `protobuf:"varint,4,opt,name=game_object_type,json=gameObjectType,proto3" json:"game_object_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Impression) Reset()         { *m = Impression{} }
func (m *Impression) String() string { return proto.CompactTextString(m) }
func (*Impression) ProtoMessage()    {}
func (*Impression) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fee483de10da73, []int{1}
}

func (m *Impression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Impression.Unmarshal(m, b)
}
func (m *Impression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Impression.Marshal(b, m, deterministic)
}
func (m *Impression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Impression.Merge(m, src)
}
func (m *Impression) XXX_Size() int {
	return xxx_messageInfo_Impression.Size(m)
}
func (m *Impression) XXX_DiscardUnknown() {
	xxx_messageInfo_Impression.DiscardUnknown(m)
}

var xxx_messageInfo_Impression proto.InternalMessageInfo

func (m *Impression) GetLocationName() string {
	if m != nil {
		return m.LocationName
	}
	return ""
}

func (m *Impression) GetImpressionType() Impression_ImpressionType {
	if m != nil {
		return m.ImpressionType
	}
	return Impression_IMPRESSION_TYPE_UNSPECIFIED
}

func (m *Impression) GetGameObjectType() int32 {
	if m != nil {
		return m.GameObjectType
	}
	return 0
}

func init() {
	proto.RegisterEnum("google.maps.playablelocations.v3.PlayerReport_BadLocationReason", PlayerReport_BadLocationReason_name, PlayerReport_BadLocationReason_value)
	proto.RegisterEnum("google.maps.playablelocations.v3.Impression_ImpressionType", Impression_ImpressionType_name, Impression_ImpressionType_value)
	proto.RegisterType((*PlayerReport)(nil), "google.maps.playablelocations.v3.PlayerReport")
	proto.RegisterType((*Impression)(nil), "google.maps.playablelocations.v3.Impression")
}

func init() {
	proto.RegisterFile("google/maps/playablelocations/v3/resources.proto", fileDescriptor_d1fee483de10da73)
}

var fileDescriptor_d1fee483de10da73 = []byte{
	// 592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4f, 0x6f, 0xd3, 0x30,
	0x1c, 0x25, 0xe9, 0x36, 0x34, 0x6b, 0x0d, 0xc1, 0x07, 0x14, 0x06, 0x68, 0x55, 0xc7, 0xa1, 0xe2,
	0x90, 0xa0, 0xf5, 0xb8, 0x0b, 0x49, 0x6a, 0x46, 0xa4, 0xd4, 0x31, 0x6e, 0x86, 0x34, 0x2e, 0x96,
	0xdb, 0x7a, 0x21, 0x90, 0xc4, 0x51, 0x92, 0x4d, 0xea, 0x87, 0xd9, 0x85, 0x23, 0x27, 0x2e, 0x7c,
	0x1f, 0x3e, 0x0a, 0x72, 0x93, 0xee, 0x0f, 0x13, 0x9a, 0xb8, 0xd9, 0xef, 0xbd, 0xdf, 0x7b, 0xb6,
	0x7f, 0xfe, 0x81, 0xb7, 0x89, 0x94, 0x49, 0x26, 0x9c, 0x9c, 0x97, 0xb5, 0x53, 0x66, 0x7c, 0xc5,
	0xe7, 0x99, 0xc8, 0xe4, 0x82, 0x37, 0xa9, 0x2c, 0x6a, 0xe7, 0x72, 0xec, 0x54, 0xa2, 0x96, 0x17,
	0xd5, 0x42, 0xd4, 0x76, 0x59, 0xc9, 0x46, 0xc2, 0x41, 0x5b, 0x61, 0xab, 0x0a, 0xfb, 0x5e, 0x85,
	0x7d, 0x39, 0xde, 0x3f, 0xe8, 0x3c, 0x79, 0x99, 0x3a, 0xe7, 0xa9, 0xc8, 0x96, 0x6c, 0x2e, 0xbe,
	0xf0, 0xcb, 0x54, 0x56, 0xad, 0xc5, 0x7e, 0x67, 0xe1, 0xac, 0x77, 0xf3, 0x8b, 0xf3, 0x4e, 0x95,
	0xf3, 0xfa, 0x5b, 0xa7, 0xb0, 0x3a, 0x45, 0xb3, 0x2a, 0x85, 0x93, 0xf1, 0x26, 0x2b, 0x92, 0x96,
	0x19, 0x5e, 0xf5, 0xc0, 0x1e, 0xc9, 0xf8, 0x4a, 0x54, 0x54, 0x94, 0xb2, 0x6a, 0xe0, 0x08, 0xf4,
	0x37, 0xe9, 0xac, 0xe0, 0xb9, 0xb0, 0xb4, 0x81, 0x36, 0xda, 0xf5, 0x7a, 0xbf, 0x5d, 0x9d, 0xee,
	0x6d, 0x18, 0xcc, 0x73, 0x01, 0x19, 0x78, 0x5c, 0x09, 0x5e, 0xcb, 0xa2, 0xb6, 0xf4, 0x41, 0x6f,
	0x64, 0x1c, 0xbd, 0xb3, 0x1f, 0xba, 0x8b, 0x7d, 0x3b, 0xca, 0xf6, 0xf8, 0x32, 0xec, 0x48, 0xba,
	0x36, 0x6a, 0x53, 0x36, 0xae, 0xf0, 0x0d, 0x30, 0xda, 0x25, 0x5b, 0x8a, 0x86, 0xa7, 0x59, 0x6d,
	0xf5, 0x6e, 0xce, 0xd2, 0x6f, 0xa9, 0x49, 0xcb, 0xc0, 0x43, 0xd0, 0xcf, 0x78, 0x91, 0x5c, 0xf0,
	0x44, 0xb0, 0x85, 0x5c, 0x0a, 0x6b, 0x4b, 0x49, 0xe9, 0xde, 0x06, 0xf4, 0xe5, 0x52, 0x0c, 0x7f,
	0x6a, 0xe0, 0xe9, 0xbd, 0x50, 0x78, 0x08, 0x0e, 0x3c, 0x77, 0xc2, 0xc2, 0xc8, 0x77, 0xe3, 0x20,
	0xc2, 0x8c, 0x22, 0x77, 0x16, 0x61, 0x76, 0x8a, 0x67, 0x04, 0xf9, 0xc1, 0xfb, 0x00, 0x4d, 0xcc,
	0x47, 0x70, 0x17, 0x6c, 0x47, 0xf1, 0x07, 0x44, 0x4d, 0x0d, 0xbe, 0x02, 0xcf, 0x71, 0x14, 0x33,
	0x82, 0x26, 0x68, 0x16, 0xd3, 0xc0, 0xc5, 0xcc, 0xf5, 0x7d, 0x34, 0x9b, 0x05, 0x5e, 0x88, 0x4c,
	0x1d, 0x3e, 0x03, 0x50, 0xd1, 0x11, 0x41, 0x98, 0xc5, 0x11, 0x23, 0xa7, 0x5e, 0x18, 0xf8, 0xe6,
	0x96, 0xc2, 0x09, 0xa2, 0x53, 0x17, 0x23, 0x1c, 0x87, 0x67, 0xcc, 0x0f, 0xa3, 0x19, 0x9a, 0x98,
	0xdb, 0xf0, 0x25, 0xb0, 0x62, 0x34, 0x25, 0x11, 0x75, 0x69, 0x10, 0x9e, 0xb1, 0x00, 0xdf, 0x72,
	0xdb, 0x19, 0x5e, 0xe9, 0x00, 0x04, 0x79, 0x59, 0x89, 0xba, 0x4e, 0x65, 0xf1, 0x1f, 0xdd, 0x49,
	0xc1, 0x93, 0xf4, 0xba, 0x8e, 0xa9, 0xc6, 0x5b, 0xfa, 0x40, 0x1b, 0x19, 0x47, 0xc7, 0x0f, 0x77,
	0xe9, 0x26, 0xf0, 0xd6, 0x32, 0x5e, 0x95, 0xa2, 0x0d, 0x32, 0xd2, 0x3b, 0x20, 0x1c, 0x01, 0x33,
	0xe1, 0xb9, 0x60, 0x72, 0xfe, 0x55, 0x2c, 0x9a, 0x36, 0x4b, 0x3d, 0xff, 0x36, 0x35, 0x14, 0x1e,
	0xad, 0x61, 0xa5, 0x1c, 0x12, 0x60, 0xdc, 0x35, 0x84, 0x07, 0xe0, 0x45, 0x30, 0x25, 0x54, 0x5d,
	0x38, 0xc2, 0x2c, 0x3e, 0x23, 0xe8, 0xaf, 0x87, 0xef, 0x83, 0x5d, 0x45, 0x23, 0x1c, 0xa3, 0x89,
	0xa9, 0x41, 0x03, 0x80, 0x00, 0xc7, 0x88, 0xba, 0xbe, 0xda, 0xeb, 0xde, 0x2f, 0x0d, 0xbc, 0x5e,
	0xc8, 0xfc, 0xc1, 0x3b, 0x79, 0x06, 0xdd, 0x0c, 0x1e, 0x51, 0x1f, 0x9f, 0x68, 0x9f, 0x3f, 0x76,
	0x35, 0x89, 0x54, 0x9f, 0xc4, 0x96, 0x55, 0xe2, 0x24, 0xa2, 0x58, 0x8f, 0x85, 0xd3, 0x52, 0xbc,
	0x4c, 0xeb, 0x7f, 0x8f, 0xf2, 0xf1, 0x3d, 0xf0, 0xbb, 0xbe, 0x75, 0x32, 0x25, 0xe1, 0x0f, 0x7d,
	0x70, 0xd2, 0x5a, 0x4f, 0xd5, 0x71, 0x48, 0x27, 0x0b, 0xaf, 0x8f, 0xf3, 0x69, 0x3c, 0xdf, 0x59,
	0xe7, 0x8c, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xfe, 0xbb, 0x44, 0x80, 0x31, 0x04, 0x00, 0x00,
}
